"""
    Ваша задача дописать функции, чтобы они проходили все тесты

    Именование функций проиходит по шаблону: `t{number_of_task}`. Пожалуйста не меняйте эти имена.

    Разрешается использовать только стандартные библиотеки языка.
"""

import re
import itertools

def t1(number):
    """
    Поправьте код что бы возвращаемое значение было ближайшим сверху, кратным к 20

    Пример: number=21 тогда нужно вернуть 40
    Пример: -5 -> 0

    """
    # А в Python 3.8+ можно использовать walrus operator,
    # чтобы не вычислять (number % 20) дважды:
    #
    # return number + 20 - rem if rem := number % 20 else number
    return number + 20 - number % 20 if number % 20 else number


def t2(string):
    """
    На вход подается набор слов разделенных пробелом, инвертируйте каждое слово.

    Пример: `abc abc abc` -> `cba cba cba`
    """
    return ' '.join( # 4. Объединили всё в одну строку
        map(
            ''.join, # 3. Сцепили каждый генератор в строку
            map(
                reversed, # 2. Развернули каждое "слово", получили генератор
                string.split() # 1. Разбили по пробелам
            )
        )
    )


def t3(dictionary):
    """
    На вход подается словарь. Преорбазуйте его в строку по следующему шаблону 'key: value; key: value' и так далее

    """
    return '; '.join(f'{key}: {value}' for key, value in dictionary.items())


def t4(string, sub_string):
    """
    проверить есть ли в строке инвертированная подстрока
    """
    return sub_string[::-1] in string


def t5(strings):
    """
    На вход подается список строк,
    Отфильтруйте список строк, оставив только строки в формате: `x y z x*y*z`, где x,y,z - целые положительные (судя по тестам - неотрицательные) числа
    """

    def check_one(s: str) -> bool:
        nonneg_ints = (
            n if n >= 0 else None # 2. Отрицательные числа заменяем чем-то неумножаемым
            for n in map(int, s.split()) # 1. Попытались преобразовать в числа
        ) # Это ленивая операция!!

        try:
            # Попытались распаковать.
            # 
            # В этот момент происходит попытка конвертации в число
            # и вылетает исключение, если конвертация не прошла.
            # Также вылетает исключение, если элементов не 4.
            x, y, z, prod = nonneg_ints

            # Это выбрасывает исключение, если один из
            # перемножаемых элементов является None
            # (см. выражение-генератор выше).
            # Также возвращает False, если prod is None.
            return x * y * z == prod
        except:
            # Если поймали исключение, то эта строка не годится
            return False

    # Наконец, фильтруем список строк.
    # 
    # Чёт сложно и вообще спагетти-код, опирающийся
    # на особенности Питона (что выбрасывает исключение, а что - нет),
    # но вроде работает и вроде прикольно)
    return list(filter(check_one, strings))


def t6(string):
    """
    Предположим у вас есть строки содержащие `#` символ, который означает backspace (удаление предыдущего) обработаете
        такие строки

    "abc#d##c"      ==>  "ac"
    "abc##d######"  ==>  ""
    "#######"       ==>  ""
    ""              ==>  ""
    """
    state = ''
    for char in string:
        if char == "#":
            state = state[:-1] # Работает, даже когда строка пустая
        else:
            state += char

    return state


def t7(lst):
    """
    На вход подается список элементов, найдите сумму уникальных элементов списка.

    Например: [4,5,7,5,4,8] -> 15 потому что 7 и 8 уникальны
    """
    return sum(
        elem
        for elem, grouper in itertools.groupby( # 2. Нашли цепочки дубликатов (grouper)
            sorted(lst) # 1. В отсортированном списке дубликаты идут друг за другом
        )
        if sum(grouper) == elem # 3. Это выполняется только если в цепочке ровно одно число
    )


def t8(string):
    """
    Найдите все последовательности числев в строке и среди них найдите максимальное число

    gh12cdy695m1 -> 695
    """
    return max( # 3. Нашли максимум среди этих чисел
        map(
            int, # 2. Преобразовали каждую такую подстроку в целое число
            re.findall(r'\d+', string) # 1. Нашли все подстроки, состоящие только из символов "0-9"
        )
    )


def t9(number):
    """
    Приведите число number к пятизначному виду.

    Т.е. для числа 5 верните `00005`
    """
    # Форматирование строк рулит!
    return f'{number:05d}'


def t10(string):
    """
    Произведите смешивание цветов. Вам будет дана строка, необходимо смешать все пары цветов и вернуть результируюший
        цвет

    Комбинации цветов:    G G     B G    R G   B R
    Результирующий цвет:   G       R      B     G

    R R G B R G B B  <- ввод
     R B R G B R B
      G G B R G G
       G R G B G
        B B R R
         B G R
          R B
           G  <-- вывод

    """
    if len(string) == 1:
        return string

    try:
        # Проверяем, что длина строки ровно 2
        a, b = string
    except ValueError:
        # Если не 2, смешиваем текущую строку...
        mixed = (
            t10(c1 + c2)
            for c1, c2 in zip(string[:-1], string[1:])
        )
        # ...и отправляем результат дальше на смешивание
        return t10(''.join(mixed))
    else:
        # Здесь в строке 2 элемента
        if a == b:
            return a

        r, = {'R', 'G', 'B'} - set(string)
        return r


def t11(lst):
    """
    Вам дам список из целых чисел. Найдите индекс числа такого, что суммы левой и правой частей списка от него равны
        Если такого элемента нет - верните -1. Если вы нашли два элемента -> верните индекс того, который левее.
    [1,2,3,5,3,2,1] = 3
    [1,12,3,3,6,3,1] = 2
    [10,20,30,40] = -1
    """
    # Здесь считается, что сумма пустого списка не определена,
    # поэтому индексы считаются с единицы и заканчиваются
    # предпоследним возможным
    for index in range(1, len(lst) - 1):
        elem = lst[index]
        left, right = lst[:index], lst[index + 1:]

        if sum(left) == sum(right):
            return index

    return -1


def t12(lst):
    """
    На вход подается список строк вида `Что-то происходит бла бла бла +7495 123-45-67` содержащие номер телефона.
        Используя regex выражения запишите всевозможноые комбинации телефонов, например программа должна корректно
        работать с 790112345678 или 890112345678
    Вход: [`Что-то происходит бла бла бла +7495 123-45-67`]
    Выход: [`84951234567`]

    """
    REGEX = re.compile(r'(\+7|7|8)\s*\(?\s*(\d{3})\s*\)?\s*(\d{3})-?(\d\d)-?(\d\d)')

    phone_numbers = []
    for line in lst:
        country, city, three, two, two_ = REGEX.search(line).groups()

        phone_numbers.append(
            ('8' if country == '+7' else country) +
            city + three + two + two_
        )

    return phone_numbers


def t13(number_1, number_2):
    """
    Сложите два числа по элементно:
        248
       +208
        4416
    """
    # Работает также с числами разной длины

    # 1. Складывать начинаем с конца числа (справа),
    # поэтому каждое число надо перевернуть
    # 129 => [9, 2, 1]
    transformer = lambda num: map(int, reversed(str(num)))
    n1, n2 = transformer(number_1), transformer(number_2)

    # 2. Приводим оба числа к одинаковой длине, вставляя нули в короткое число,
    # и складываем цифры. Результат по-прежнему задом наперёд.
    # [9, 2, 1] + [3, 1] => [9, 2, 1] + [3, 1, 0] => [9 + 3, 2 + 1, 1 + 0]
    digits_sums = [a + b for a, b in itertools.zip_longest(n1, n2, fillvalue=0)]

    # 3. Переворачиваем 
    # [12, 3, 1] => [1, 3, 12] => '1312' => 1312
    return int(''.join(map(str, reversed(digits_sums))))


def t14(string):
    """
    Преобразуйте математическое выражение (символьное) в буквенное выраэение

    Для операций используйте следующую таблицу
        { '+':   'Plus ',
          '-':   'Minus ',
          '*':   'Times ',
          '/':   'Divided By ',
          '**':  'To The Power Of ',
          '=':   'Equals ',
          '!=':  'Does Not Equal ' }
    Примеры:
        4 ** 9 -> Four To The Power Of Nine
        10 - 5 -> Ten Minus Five
        2 = 2  -> Two Equals Two
    """
    map_op = {
        '+':   'Plus ',
        '-':   'Minus ',
        '*':   'Times ',
        '/':   'Divided By ',
        '**':  'To The Power Of ',
        '=':   'Equals ',
        '!=':  'Does Not Equal '
    }
    map_num = [
        'Zero', 'One', 'Two', 'Three', 'Four', 'Five', 'Six', 'Seven', 'Eight', 'Nine',
        'Ten', 'Eleven', 'Twelve', 'Thirteen', 'Fifteen', 'Sixteen', 'Seventeen', 'Eighteen', 'Nineteen'
    ]

    left, op, right = string.split()

    return f'{map_num[int(left)]} {map_op[op]}{map_num[int(right)]}'


def t15(lst):
    """
    Найдите сумму элементов на диагоналях

    [[ 1, 2, 3 ],
    [ 4, 5, 6 ],
    [ 7, 8, 9 ]]
    Результат: 30
    """
    left, right = 0, -1
    the_sum = 0

    for row in lst:
        the_sum += row[left] + row[right]
        left += 1
        right -= 1

    return the_sum

